package com.turingpoint.controller.polling;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.StatusType;

import org.json.JSONArray;
import org.json.JSONObject;

import com.turingpoint.controller.ServerContext;
import com.turingpoint.controller.ServerTypes;
import com.turingpoint.dbmodel.db.dto.LectureStatus;
import com.turingpoint.dbmodel.db.mapping.ActiveQuestion;
import com.turingpoint.dbmodel.db.mapping.Course;
import com.turingpoint.dbmodel.db.mapping.Lecture;
import com.turingpoint.dbmodel.db.mapping.Question;
import com.turingpoint.dbmodel.db.mapping.QuestionOption;
import com.turingpoint.dbmodel.db.mapping.User;
import com.turingpoint.dbmodel.db.persister.CoursePersister;
import com.turingpoint.dbmodel.db.persister.LecturePersister;
import com.turingpoint.dbmodel.db.persister.QuestionOptionPersister;
import com.turingpoint.dbmodel.db.persister.QuestionPersister;
import com.turingpoint.dbmodel.db.persister.ResponsePersister;
import com.turingpoint.dbmodel.model.QuestionType;
import com.turingpoint.dbmodel.model.Role;

@Path("/question")
@Produces(MediaType.APPLICATION_JSON)
public class QuestionServices {

	ServerContext server = ServerContext.INSTANCE;

    @GET
    @Path("/{questionID}")
    public Response GetQuestionDetail(@PathParam("questionID") Long questionID)
    {
    	return QuestionCommon.getQuestion(questionID, false);
    }

    @POST
    @Path("/{questionID}/answer")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response AnswerQuestion(InputStream inputJSON, @PathParam("questionID") Long questionID)
    {
    	JSONObject responseObject = new JSONObject();
    	String msg = "";
    	Long optionId = (long) 0;
    	ArrayList<Long> optionIds = new ArrayList<Long>();
    	String selectedAnswers = "";
    	String response = "";
    	
    	Question questionInQuestion = Question.getQuestion(questionID);
    	if(questionInQuestion == null)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Could not retrieve questionID: "+ questionID;
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}

    	
    	//check question is on before accepting asnwer
    	//find out which course the question is in
    	try
    	{
    		long lectureForQuestion = questionInQuestion.getLectureId();
    		long courseForLecture = Lecture.getLecture(lectureForQuestion).getClassId();
    		ActiveQuestion A = ActiveQuestion.getActiveQuestion(courseForLecture, questionID);
    		
    		if(A==null)
    		{
    			//TODO: Log bad user id and stack trace
        		msg = "Question not open for response";
        		responseObject.put("msg",msg);
        		return Response.status(403).entity(responseObject.toString()).build();
    		}
    	}
    	catch(Exception e)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Could not retrieve state for questionID: "+ questionID;
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}

    	//Validate input is json
    	JSONObject inputObject;
    	try
    	{
    		inputObject = ServerTypes.StringToJSON(inputJSON);
    	}
    	catch(Exception e)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Malformed Request Packet";
    		System.out.println("QuestionServices | 122 | Malformed JSON | " + ServerTypes.StreamToString(inputJSON));
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	
    	
    	Integer currentQuestionVersion = questionInQuestion.getVersion();
    	
    	Long userId;
    	Integer version;
    	//Validate parameters
    	try
    	{
			userId = inputObject.getLong("userId");
			version= inputObject.getInt("version");
			if(questionInQuestion.getType().equals(QuestionType.MULTIPLE_CHOICE))
			{
				optionId = inputObject.getLong("optionId");
			}
			else if(questionInQuestion.getType().equals(QuestionType.FILL_IN_BLANK) || questionInQuestion.getType().equals(QuestionType.NUMERIC_RESPONSE))
			{
				//clear trailing or leading space
				response = inputObject.getString("response").trim();
				optionId = QuestionOptionPersister.getQuestionOptions(questionID).get(0).getOptionId();	
			}
			else if (questionInQuestion.getType().equals(QuestionType.MULTIPLE_ANSWER))
			{
				optionId = QuestionOptionPersister.getQuestionOptions(questionID).get(0).getOptionId();	
				JSONArray arr = inputObject.getJSONArray("optionIds");
				for (Object x: arr)
				{
					selectedAnswers += x.toString() + ",";
				}
				
				// Get rid of the extra ", " on the end
				if (selectedAnswers != null)
				{
					selectedAnswers = selectedAnswers.substring(0, selectedAnswers.length() - 1);
				}
			}
    	}
    	catch(Exception e)
    	{
    		msg = "Request lacks required parameters: " + inputJSON.toString();
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	
    	if(version == currentQuestionVersion)
    	{
	
	    	//check if this response is in the cache already.... this is the only way i know of to avoid a massive fkup
	    	com.turingpoint.dbmodel.db.mapping.Response ans;
	    	
	    	//when this comes back with an existing object, we cant create a new response, so we update the existing one
	    	ans = com.turingpoint.dbmodel.db.mapping.Response.getResponse(userId, questionID);
	    	
	    	if(ans == null)
	    	{
	    		ans = ResponsePersister.storeNewResponse(userId, questionID, optionId, response, selectedAnswers);
	    	}
	    	else
	    	{
	        	if(inputObject.has("optionId"))
	        		ans.setOptionId(optionId);
	        	else
	        	{
	        		ans.setTextResponse(response);
	        		ans.setSelectedAnswers(selectedAnswers);
	        	}       		
	        	
	        	ans.update();
	    	}
	
	    	try
	    	{
	    		server.putCacheResponse(questionID, ans);
	    	}
	    	catch(Exception e)
	    	{
	    		System.err.println("QuestionServices | 145 | Cannot rapid cache question, was the server restarted?");
	    	}
	    	
	    	

	    	msg = "Answer Accepted";
	    	responseObject.put("msg", msg);
	    	return Response.status(200).entity(responseObject.toString()).build();
    	}
    	
    	msg = "Old Version";
    	responseObject.put("msg", msg);
    	return Response.status(400).entity(responseObject.toString()).build();

    }

    @POST
    @Path("/{questionID}/start")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response StartQuestion(InputStream inputJSON, @PathParam("questionID") Long questionID)
    {
    	JSONObject responseObject = new JSONObject();
    	String msg = "";

    	//Validate input is json
    	JSONObject inputObject;
    	try
    	{
    		inputObject = ServerTypes.StringToJSON(inputJSON);
    	}
    	catch(Exception e)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Malformed Request Packet";
    		System.out.println("QuestionServices | 226 | Malformed JSON | " + ServerTypes.StreamToString(inputJSON));
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	
    	long courseId;
    	
    	try
    	{
    		courseId = inputObject.getLong("courseId");
    	}
    	catch(Exception e)
    	{
    		msg = "Request lacks required parameters: " + inputJSON.toString();
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	//Start the question cache here to ensure its always open before responses come in
    	server.putCacheQuestion(questionID, Question.getQuestion(questionID).getType());
    	
    	//open question
    	
    	try
    	{
    		QuestionPersister.startQuestion(courseId, questionID);
    	}
    	catch(Exception e)
    	{
    		msg = "Question already started";
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}

    	//reply to client
    	msg = "Question Started";
    	responseObject.put("msg", msg);
    	responseObject.put("questionId", questionID);
    	return Response.status(200).entity(responseObject.toString()).build();
    }

    @POST
    @Path("/{questionID}/end")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response EndQuestion(InputStream inputJSON, @PathParam("questionID") Long questionID)
    {
    	JSONObject responseObject = new JSONObject();
    	String msg = "";

    	//Validate input is json
    	JSONObject inputObject;
    	try
    	{
    		inputObject = ServerTypes.StringToJSON(inputJSON);
    	}
    	catch(Exception e)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Malformed Request Packet "+ inputJSON.toString();
    		System.out.println("QuestionServices | 264 | Malformed JSON | " + ServerTypes.StreamToString(inputJSON));
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	long courseId;
    	
    	try
    	{
    		courseId = inputObject.getLong("courseId");
    	}
    	catch(Exception e)
    	{
    		msg = "Request lacks required parameters: " + inputJSON.toString();
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}

    	QuestionPersister.endQuestion(courseId, questionID);
    	
    	server.dropCache(questionID);
    	
    	msg = "Question ended";
    	responseObject.put("msg", msg);
    	responseObject.put("questionId", questionID);
    	return Response.status(200).entity(responseObject.toString()).build();
    }

    
    ////I say we just call the first one and always use the post method at this point - Tony
    @PUT
    @Path("/{questionID}/answer")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response AnswerQuestionAgain(InputStream inputJSON, @PathParam("questionID") Long questionID)
    {
    	JSONObject responseObject = new JSONObject();
    	String msg = "";
    	Long optionId = (long) 0;
    	String response = "";

    	//Validate input is json
    	JSONObject inputObject;
    	try
    	{
    		inputObject = ServerTypes.StringToJSON(inputJSON);
    	}
    	catch(Exception e)
    	{
    		//TODO: Log bad user id and stack trace
    		msg = "Malformed Request Packet "+ inputJSON.toString();
    		System.out.println("QuestionServices | 303 | Malformed JSON | " + ServerTypes.StreamToString(inputJSON));
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	long userId;
    	int version;
    	
    	try
    	{
    		userId = inputObject.getLong("userId");
        	version = inputObject.getInt("version");
        	if(inputObject.has("optionId"))
        	{
        		optionId = inputObject.getLong("optionId");
        		//optionId = Long.parseLong((String)inputObject.get("optionId"));
        	}
        	else if(inputObject.has("response"))
        	{
        		response = inputObject.getString("response");
        	}
    	}
    	catch(Exception e)
    	{
    		msg = "Request lacks required parameters: " + inputJSON.toString();
    		responseObject.put("msg",msg);
    		return Response.status(415).entity(responseObject.toString()).build();
    	}
    	
    	msg = "Update Accepted";
    	responseObject.put("msg", msg);
    	return Response.status(200).entity(responseObject.toString()).build();
    }

    @POST
    @Path("/{questionID}/setGroup")
    @Consumes(MediaType.APPLICATION_JSON)
    //TODO: Finish when question persister supports this operation
    public Response SetQuestionGroup(@PathParam("questionID") Long questionID)
    {
    	String wildCard = "Service Not Yet Implemented";
    	JSONObject responseObject = new JSONObject();
    	responseObject.put("msg", wildCard);
    	return Response.status(200).entity(responseObject.toString()).build();
    }

    @POST
    @Path("/create")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response CreateQuestion(InputStream inputJSON)
    {
    	return QuestionCommon.createQuestion(inputJSON, false);
    }

    @PUT
    @Path("/{questionID}/update")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response EditQuestion(InputStream inputJSON, @PathParam("questionID") Long questionID)
    {
    	return QuestionCommon.updateQuestion(questionID, inputJSON, false);
    }
    
    @POST
    @Path("/{questionID}/delete")
    @Consumes(MediaType.APPLICATION_JSON)
    //TODO: Finish when question persister supports this operation (Not phase 1)
    public Response DeleteQuestion(InputStream inputJSON,@PathParam("questionID") Long questionID)  
    {
    	return QuestionCommon.deleteQuestion(questionID, inputJSON, false);
    }

}
